---
title: Data Flow
description: Tracing the network lifecycle of Inbound, Outbound, and Web conversations.
---

import { Network, Server, ArrowDown, Activity, Globe, PhoneIncoming, PhoneOutgoing } from 'lucide-react';
import { Step, Steps } from 'fumadocs-ui/components/steps';

Understanding how data moves through the Iqra AI cluster is essential for debugging latency, configuring firewalls, and understanding the role of the **Proxy** vs. the **Backend**.

## Scenario A: Inbound Telephony
**"The Router"**

This flow triggers when a human calls a phone number connected to your platform. The Carrier asks the Proxy where to send the audio.

```mermaid
sequenceDiagram
    participant Carrier as Telephony Carrier
    participant Proxy as IqraProxyApp
    participant DB as MongoDB/Redis
    participant Backend as IqraBackendApp

    Note over Carrier, Proxy: 1. Signaling
    Carrier->>Proxy: HTTP POST /webhook/incoming
    
    Note over Proxy, DB: 2. Routing Logic
    Proxy->>DB: Lookup Phone Number
    DB-->>Proxy: Return Business, Region, & Route
    
    Note over Proxy: 3. Load Balancing
    Proxy->>Proxy: ServerSelectionManager.GetBestServer(Region)
    
    Note over Proxy, Backend: 4. Handoff
    Proxy->>Backend: POST /internal/allocate-call
    Backend-->>Proxy: OK (Ready to accept)
    Proxy-->>Carrier: Return TwiML/XML <Connect wss://backend... />
    
    Note over Carrier, Backend: 5. Media Stream
    Carrier->>Backend: Open WebSocket/RTP Stream
    Backend->>Carrier: Send Audio Stream
```

---

## Scenario B: Outbound Telephony
**"The Dispatcher"**

This flow triggers when you launch a call via API or the Dashboard. It involves an asynchronous queue system.

```mermaid
sequenceDiagram
    participant User as API / Dashboard
    participant DB as MongoDB (Queue)
    participant Proxy as IqraProxyApp (Dispatcher)
    participant Carrier as Twilio/Telnyx
    participant Backend as IqraBackendApp

    Note over User, DB: 1. Enqueue
    User->>DB: Insert Call Queue Item
    
    Note over Proxy, DB: 2. Polling & Dispatch
    Proxy->>DB: Poll Pending Items (Per Region)
    DB-->>Proxy: Return Job
    
    Note over Proxy, Backend: 3. Reservation
    Proxy->>Backend: POST /internal/allocate-outbound
    Backend-->>Proxy: OK (Waiting for connection)
    
    Note over Proxy, Carrier: 4. Dialing
    Proxy->>Carrier: REST API (Initiate Call to +123...)
    Note right of Proxy: Url = wss://backend-ip/ws
    
    Note over Carrier, Backend: 5. Connection
    Carrier->>Backend: Call Connected -> Handshake
    Backend->>Carrier: Agent Greeting Audio
```

*   **Why the Proxy dials?** The Proxy manages the global rate limits (CPS) and concurrency for the Business before the heavy Backend server is involved.

---

## Scenario C: Web Session (WebRTC)
**"The Direct Line"**

This flow bypasses the Telephony Proxy entirely. The Frontend API acts as the gatekeeper, handing a "Ticket" (Signed URL) to the browser to connect directly to the brain.

```mermaid
sequenceDiagram
    participant Client as Browser SDK
    participant Front as IqraFrontend
    participant Redis as Redis
    participant Backend as IqraBackendApp

    Note over Client, Front: 1. Authentication
    Client->>Front: POST /api/session/init (Auth Token)
    
    Note over Front, Redis: 2. Load Balancing
    Front->>Redis: Check Concurrency Limit
    Front->>Redis: Get Least Loaded Backend
    
    Note over Front, Client: 3. Handoff
    Front-->>Client: Return Signed URL (wss://backend-ip/ws?token=...)
    
    Note over Client, Backend: 4. Real-time Stream
    Client->>Backend: Connect WebSocket
    Backend->>Client: Upgrade to WebRTC (if supported)
    Client->>Backend: Stream Microphone (PCM/Opus)
    Backend->>Client: Stream Agent Audio
```

<Callout type="info" title="Latency Advantage">
  Web Sessions are significantly faster than Telephony scenarios because there is no Carrier middleware (Twilio/Telnyx) processing the audio packets. The browser speaks directly to the Iqra Backend.
</Callout>